/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Letta from "../../../index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";
import * as stream from "stream";

export declare namespace Agents {
    interface Options {
        environment?: core.Supplier<environments.LettaEnvironment | string>;
        token: core.Supplier<core.BearerToken>;
        fetcher?: core.FetchFunction;
    }

    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}

export class Agents {
    constructor(protected readonly _options: Agents.Options) {}

    /**
     * List all agents associated with a given user.
     * This endpoint retrieves a list of all agents and their configurations associated with the specified user ID.
     *
     * @param {Letta.AgentsListRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.list()
     */
    public list(
        request: Letta.AgentsListRequest = {},
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentState[]> {
        return core.APIPromise.from(
            (async () => {
                const { name, tags } = request;
                const _queryParams: Record<string, string | string[] | object | object[]> = {};
                if (name != null) {
                    _queryParams["name"] = name;
                }
                if (tags != null) {
                    if (Array.isArray(tags)) {
                        _queryParams["tags"] = tags.map((item) => item);
                    } else {
                        _queryParams["tags"] = tags;
                    }
                }
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        "v1/agents/"
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    queryParameters: _queryParams,
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentState[],
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError("Timeout exceeded when calling GET /v1/agents/.");
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Create a new agent with the specified configuration.
     *
     * @param {Letta.CreateAgent} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.create()
     */
    public create(
        request: Letta.CreateAgent = {},
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentState> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        "v1/agents/"
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentState,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError("Timeout exceeded when calling POST /v1/agents/.");
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve the context window of a specific agent.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.getContextWindow("agent_id")
     */
    public getContextWindow(
        agentId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.ContextWindowOverview> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/context`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.ContextWindowOverview,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/context."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Get the sources associated with an agent.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.get("agent_id")
     */
    public get(agentId: string, requestOptions?: Agents.RequestOptions): core.APIPromise<Letta.Source[]> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/sources`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Source[],
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/sources."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Delete an agent.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.delete("agent_id")
     */
    public delete(agentId: string, requestOptions?: Agents.RequestOptions): core.APIPromise<unknown> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}`
                    ),
                    method: "DELETE",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling DELETE /v1/agents/{agent_id}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Update an exsiting agent
     *
     * @param {string} agentId
     * @param {Letta.UpdateAgentState} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.update("agent_id", {
     *         id: "id"
     *     })
     */
    public update(
        agentId: string,
        request: Letta.UpdateAgentState,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentState> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentState,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Get tools from an existing agent
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.listTools("agent_id")
     */
    public listTools(
        agentId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.LettaSchemasToolTool[]> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/tools`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.LettaSchemasToolTool[],
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/tools."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Add tools to an existing agent
     *
     * @param {string} agentId
     * @param {string} toolId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.addToTool("agent_id", "tool_id")
     */
    public addToTool(
        agentId: string,
        toolId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentState> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/add-tool/${encodeURIComponent(toolId)}`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentState,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}/add-tool/{tool_id}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Add tools to an existing agent
     *
     * @param {string} agentId
     * @param {string} toolId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.removeFromTool("agent_id", "tool_id")
     */
    public removeFromTool(
        agentId: string,
        toolId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentState> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/remove-tool/${encodeURIComponent(toolId)}`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentState,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}/remove-tool/{tool_id}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve the messages in the context of a specific agent.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.listInContextMessages("agent_id")
     */
    public listInContextMessages(
        agentId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.LettaSchemasMessageMessageOutput[]> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/messages`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.LettaSchemasMessageMessageOutput[],
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/memory/messages."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve the memory state of a specific agent.
     * This endpoint fetches the current memory state of the agent identified by the user ID and agent ID.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.getMemory("agent_id")
     */
    public getMemory(agentId: string, requestOptions?: Agents.RequestOptions): core.APIPromise<Letta.Memory> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Memory,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/memory."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Update the core memory of a specific agent.
     *     This endpoint accepts new memory contents (labels as keys, and values as values) and updates the core memory of the agent identified by the user ID and agent ID.
     * This endpoint accepts new memory contents to update the core memory of the agent.
     * This endpoint only supports modifying existing blocks; it does not support deleting/unlinking or creating/linking blocks.
     *
     * @param {string} agentId
     * @param {Record<string, unknown>} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.updateMemory("agent_id", {
     *         "key": "value"
     *     })
     */
    public updateMemory(
        agentId: string,
        request: Record<string, unknown>,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Memory> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Memory,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}/memory."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Update the label of a block in an agent's memory.
     *
     * @param {string} agentId
     * @param {Letta.BlockLabelUpdate} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.updateMemoryLabel("agent_id", {
     *         current_label: "current_label",
     *         new_label: "new_label"
     *     })
     */
    public updateMemoryLabel(
        agentId: string,
        request: Letta.BlockLabelUpdate,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Memory> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/label`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Memory,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}/memory/label."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Creates a memory block and links it to the agent.
     *
     * @param {string} agentId
     * @param {Letta.BlockCreate} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.addMemory("agent_id", {
     *         value: "value",
     *         label: "label"
     *     })
     */
    public addMemory(
        agentId: string,
        request: Letta.BlockCreate,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Memory> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/block`
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Memory,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling POST /v1/agents/{agent_id}/memory/block."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Removes a memory block from an agent by unlnking it. If the block is not linked to any other agent, it is deleted.
     *
     * @param {string} agentId
     * @param {string} blockLabel
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.removeMemory("agent_id", "block_label")
     */
    public removeMemory(
        agentId: string,
        blockLabel: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Memory> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/block/${encodeURIComponent(blockLabel)}`
                    ),
                    method: "DELETE",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Memory,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling DELETE /v1/agents/{agent_id}/memory/block/{block_label}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Update the limit of a block in an agent's memory.
     *
     * @param {string} agentId
     * @param {Letta.BlockLimitUpdate} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.updateMemoryLimit("agent_id", {
     *         label: "label",
     *         limit: 1
     *     })
     */
    public updateMemoryLimit(
        agentId: string,
        request: Letta.BlockLimitUpdate,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Memory> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/limit`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Memory,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}/memory/limit."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve the summary of the recall memory of a specific agent.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.getRecallMemorySummary("agent_id")
     */
    public getRecallMemorySummary(
        agentId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.RecallMemorySummary> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/recall`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.RecallMemorySummary,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/memory/recall."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve the summary of the archival memory of a specific agent.
     *
     * @param {string} agentId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.getArchivalMemorySummary("agent_id")
     */
    public getArchivalMemorySummary(
        agentId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.ArchivalMemorySummary> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/memory/archival`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.ArchivalMemorySummary,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/memory/archival."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve the memories in an agent's archival memory store (paginated query).
     *
     * @param {string} agentId
     * @param {Letta.AgentsListArchivalMemoryRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.listArchivalMemory("agent_id")
     */
    public listArchivalMemory(
        agentId: string,
        request: Letta.AgentsListArchivalMemoryRequest = {},
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Passage[]> {
        return core.APIPromise.from(
            (async () => {
                const { after, before, limit } = request;
                const _queryParams: Record<string, string | string[] | object | object[]> = {};
                if (after != null) {
                    _queryParams["after"] = after.toString();
                }
                if (before != null) {
                    _queryParams["before"] = before.toString();
                }
                if (limit != null) {
                    _queryParams["limit"] = limit.toString();
                }
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/archival`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    queryParameters: _queryParams,
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Passage[],
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/archival."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Insert a memory into an agent's archival memory store.
     *
     * @param {string} agentId
     * @param {Letta.CreateArchivalMemory} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.createArchivalMemory("agent_id", {
     *         text: "text"
     *     })
     */
    public createArchivalMemory(
        agentId: string,
        request: Letta.CreateArchivalMemory,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.Passage[]> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/archival`
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.Passage[],
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling POST /v1/agents/{agent_id}/archival."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Delete a memory from an agent's archival memory store.
     *
     * @param {string} agentId
     * @param {string} memoryId
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.deleteArchivalMemory("agent_id", "memory_id")
     */
    public deleteArchivalMemory(
        agentId: string,
        memoryId: string,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<unknown> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/archival/${encodeURIComponent(memoryId)}`
                    ),
                    method: "DELETE",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling DELETE /v1/agents/{agent_id}/archival/{memory_id}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Retrieve message history for an agent.
     *
     * @param {string} agentId
     * @param {Letta.AgentsListMessagesRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.listMessages("agent_id")
     */
    public listMessages(
        agentId: string,
        request: Letta.AgentsListMessagesRequest = {},
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentsListMessagesResponse> {
        return core.APIPromise.from(
            (async () => {
                const {
                    before,
                    limit,
                    msg_object: msgObject,
                    assistant_message_tool_name: assistantMessageToolName,
                    assistant_message_tool_kwarg: assistantMessageToolKwarg,
                } = request;
                const _queryParams: Record<string, string | string[] | object | object[]> = {};
                if (before != null) {
                    _queryParams["before"] = before;
                }
                if (limit != null) {
                    _queryParams["limit"] = limit.toString();
                }
                if (msgObject != null) {
                    _queryParams["msg_object"] = msgObject.toString();
                }
                if (assistantMessageToolName != null) {
                    _queryParams["assistant_message_tool_name"] = assistantMessageToolName;
                }
                if (assistantMessageToolKwarg != null) {
                    _queryParams["assistant_message_tool_kwarg"] = assistantMessageToolKwarg;
                }
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/messages`
                    ),
                    method: "GET",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    queryParameters: _queryParams,
                    requestType: "json",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentsListMessagesResponse,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling GET /v1/agents/{agent_id}/messages."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Process a user message and return the agent's response.
     * This endpoint accepts a message from a user and processes it through the agent.
     *
     * @param {string} agentId
     * @param {Letta.LettaRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.createMessage("agent_id", {
     *         messages: [{
     *                 role: "user",
     *                 text: "text"
     *             }]
     *     })
     */
    public createMessage(
        agentId: string,
        request: Letta.LettaRequest,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.LettaResponse> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/messages`
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.LettaResponse,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling POST /v1/agents/{agent_id}/messages."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Update the details of a message associated with an agent.
     *
     * @param {string} agentId
     * @param {string} messageId
     * @param {Letta.UpdateMessage} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.agents.updateMessage("agent_id", "message_id", {
     *         id: "id"
     *     })
     */
    public updateMessage(
        agentId: string,
        messageId: string,
        request: Letta.UpdateMessage,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.LettaSchemasMessageMessageOutput> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/messages/${encodeURIComponent(messageId)}`
                    ),
                    method: "PATCH",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.LettaSchemasMessageMessageOutput,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling PATCH /v1/agents/{agent_id}/messages/{message_id}."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Process a user message and return the agent's response.
     * This endpoint accepts a message from a user and processes it through the agent.
     * It will stream the steps of the response always, and stream the tokens if 'stream_tokens' is set to True.
     */
    public streamMessage(
        agentId: string,
        request: Letta.LettaStreamingRequest,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<core.Stream<unknown>> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)<stream.Readable>({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/messages/stream`
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    responseType: "sse",
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: new core.Stream({
                            stream: _response.body,
                            parse: async (data) => {
                                return data;
                            },
                            signal: requestOptions?.abortSignal,
                            eventShape: {
                                type: "sse",
                                streamTerminator: "[DONE]",
                            },
                        }),
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 422:
                            throw new Letta.UnprocessableEntityError(_response.error.body as Letta.HttpValidationError);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling POST /v1/agents/{agent_id}/messages/stream."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Creates a versioned version of an agent
     *
     * @param {string} agentId - The agent ID of the agent to migrate, if this agent is not a template, it will create a agent template from the agent provided as well
     * @param {Letta.AgentsVersionTemplateRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.NotFoundError}
     * @throws {@link Letta.InternalServerError}
     *
     * @example
     *     await client.agents.versionTemplate("agent_id")
     */
    public versionTemplate(
        agentId: string,
        request: Letta.AgentsVersionTemplateRequest = {},
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentsVersionTemplateResponse> {
        return core.APIPromise.from(
            (async () => {
                const { returnAgentId, ..._body } = request;
                const _queryParams: Record<string, string | string[] | object | object[]> = {};
                if (returnAgentId != null) {
                    _queryParams["returnAgentId"] = returnAgentId.toString();
                }
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/version-template`
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    queryParameters: _queryParams,
                    requestType: "json",
                    body: _body,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentsVersionTemplateResponse,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 404:
                            throw new Letta.NotFoundError(_response.error.body as unknown);
                        case 500:
                            throw new Letta.InternalServerError(_response.error.body as unknown);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling POST /v1/agents/{agent_id}/version-template."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    /**
     * Migrate an agent to a new versioned agent template
     *
     * @param {string} agentId
     * @param {Letta.AgentsMigrateRequest} request
     * @param {Agents.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.NotFoundError}
     * @throws {@link Letta.ConflictError}
     * @throws {@link Letta.InternalServerError}
     *
     * @example
     *     await client.agents.migrate("agent_id", {
     *         to_template: "to_template",
     *         preserve_core_memories: true
     *     })
     */
    public migrate(
        agentId: string,
        request: Letta.AgentsMigrateRequest,
        requestOptions?: Agents.RequestOptions
    ): core.APIPromise<Letta.AgentsMigrateResponse> {
        return core.APIPromise.from(
            (async () => {
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: urlJoin(
                        (await core.Supplier.get(this._options.environment)) ??
                            environments.LettaEnvironment.LettaHosted,
                        `v1/agents/${encodeURIComponent(agentId)}/migrate`
                    ),
                    method: "POST",
                    headers: {
                        Authorization: await this._getAuthorizationHeader(),
                        "X-Fern-Language": "JavaScript",
                        "X-Fern-SDK-Name": "letta",
                        "X-Fern-SDK-Version": "0.5.3",
                        "User-Agent": "letta/0.5.3",
                        "X-Fern-Runtime": core.RUNTIME.type,
                        "X-Fern-Runtime-Version": core.RUNTIME.version,
                        ...requestOptions?.headers,
                    },
                    contentType: "application/json",
                    requestType: "json",
                    body: request,
                    timeoutMs:
                        requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                    maxRetries: requestOptions?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        ok: _response.ok,
                        body: _response.body as Letta.AgentsMigrateResponse,
                        headers: _response.headers,
                    };
                }
                if (_response.error.reason === "status-code") {
                    switch (_response.error.statusCode) {
                        case 404:
                            throw new Letta.NotFoundError(_response.error.body as unknown);
                        case 409:
                            throw new Letta.ConflictError(_response.error.body as Letta.ConflictErrorBody);
                        case 500:
                            throw new Letta.InternalServerError(_response.error.body as unknown);
                        default:
                            throw new errors.LettaError({
                                statusCode: _response.error.statusCode,
                                body: _response.error.body,
                            });
                    }
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.LettaError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                        });
                    case "timeout":
                        throw new errors.LettaTimeoutError(
                            "Timeout exceeded when calling POST /v1/agents/{agent_id}/migrate."
                        );
                    case "unknown":
                        throw new errors.LettaError({
                            message: _response.error.errorMessage,
                        });
                }
            })()
        );
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
