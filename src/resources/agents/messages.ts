// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../core/resource';
import * as MessagesAPI from './messages';
import * as RunsAPI from '../runs';
import * as AgentsAPI from './agents';
import * as ToolsAPI from '../tools/tools';
import { APIPromise } from '../../core/api-promise';
import { RequestOptions } from '../../internal/request-options';
import { path } from '../../internal/utils/path';

export class Messages extends APIResource {
  /**
   * Update the details of a message associated with an agent.
   */
  update(
    messageID: string,
    params: MessageUpdateParams,
    options?: RequestOptions,
  ): APIPromise<MessageUpdateResponse> {
    const { agent_id, ...body } = params;
    return this._client.patch(path`/v1/agents/${agent_id}/messages/${messageID}`, { body, ...options });
  }

  /**
   * Retrieve message history for an agent.
   */
  list(
    agentID: string,
    query: MessageListParams | null | undefined = {},
    options?: RequestOptions,
  ): APIPromise<MessageListResponse> {
    return this._client.get(path`/v1/agents/${agentID}/messages`, { query, ...options });
  }

  /**
   * Cancel runs associated with an agent. If run_ids are passed in, cancel those in
   * particular.
   *
   * Note to cancel active runs associated with an agent, redis is required.
   */
  cancel(
    agentID: string,
    body: MessageCancelParams | null | undefined = {},
    options?: RequestOptions,
  ): APIPromise<MessageCancelResponse> {
    return this._client.post(path`/v1/agents/${agentID}/messages/cancel`, { body, ...options });
  }

  /**
   * Inspect the raw LLM request payload without sending it.
   *
   * This endpoint processes the message through the agent loop up until the LLM
   * request, then returns the raw request payload that would be sent to the LLM
   * provider. Useful for debugging and inspection.
   */
  previewRawPayload(
    agentID: string,
    body: MessagePreviewRawPayloadParams,
    options?: RequestOptions,
  ): APIPromise<MessagePreviewRawPayloadResponse> {
    return this._client.post(path`/v1/agents/${agentID}/messages/preview-raw-payload`, { body, ...options });
  }

  /**
   * Search messages across the entire organization with optional project and
   * template filtering. Returns messages with FTS/vector ranks and total RRF score.
   *
   * This is a cloud-only feature.
   */
  search(body: MessageSearchParams, options?: RequestOptions): APIPromise<MessageSearchResponse> {
    return this._client.post('/v1/agents/messages/search', { body, ...options });
  }

  /**
   * Process a user message and return the agent's response. This endpoint accepts a
   * message from a user and processes it through the agent.
   */
  send(agentID: string, body: MessageSendParams, options?: RequestOptions): APIPromise<LettaResponse> {
    return this._client.post(path`/v1/agents/${agentID}/messages`, { body, ...options });
  }

  /**
   * Asynchronously process a user message and return a run object. The actual
   * processing happens in the background, and the status can be checked using the
   * run ID.
   *
   * This is "asynchronous" in the sense that it's a background job and explicitly
   * must be fetched by the run ID. This is more like `send_message_job`
   */
  sendAsync(agentID: string, body: MessageSendAsyncParams, options?: RequestOptions): APIPromise<Run> {
    return this._client.post(path`/v1/agents/${agentID}/messages/async`, { body, ...options });
  }

  /**
   * Process a user message and return the agent's response. This endpoint accepts a
   * message from a user and processes it through the agent. It will stream the steps
   * of the response always, and stream the tokens if 'stream_tokens' is set to True.
   */
  sendStream(agentID: string, body: MessageSendStreamParams, options?: RequestOptions): APIPromise<unknown> {
    return this._client.post(path`/v1/agents/${agentID}/messages/stream`, { body, ...options });
  }
}

/**
 * Input to approve or deny a tool call request
 */
export interface ApprovalCreate {
  /**
   * The message ID of the approval request
   */
  approval_request_id: string;

  /**
   * Whether the tool has been approved
   */
  approve: boolean;

  /**
   * An optional explanation for the provided approval status
   */
  reason?: string | null;

  /**
   * The message type to be created.
   */
  type?: 'approval';
}

/**
 * A message representing a request for approval to call a tool (generated by the
 * LLM to trigger tool execution).
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message tool_call (ToolCall): The tool call
 */
export interface ApprovalRequestMessage {
  id: string;

  date: string;

  /**
   * The tool call that has been requested by the llm to run
   */
  tool_call: ToolCall | ToolCallDelta;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'approval_request_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

/**
 * A message representing a response form the user indicating whether a tool has
 * been approved to run.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message approve: (bool) Whether the tool has been approved approval_request_id:
 * The ID of the approval request reason: (Optional[str]) An optional explanation
 * for the provided approval status
 */
export interface ApprovalResponseMessage {
  id: string;

  /**
   * The message ID of the approval request
   */
  approval_request_id: string;

  /**
   * Whether the tool has been approved
   */
  approve: boolean;

  date: string;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'approval_response_message';

  name?: string | null;

  otid?: string | null;

  /**
   * An optional explanation for the provided approval status
   */
  reason?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

/**
 * A message sent by the LLM in response to user input. Used in the LLM context.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message content (Union[str, List[LettaAssistantMessageContentUnion]]): The
 * message content sent by the agent (can be a string or an array of content parts)
 */
export interface AssistantMessage {
  id: string;

  /**
   * The message content sent by the agent (can be a string or an array of content
   * parts)
   */
  content: Array<LettaAssistantMessageContentUnion> | string;

  date: string;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'assistant_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

/**
 * Representation of an agent's internal reasoning where reasoning content has been
 * hidden from the response.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message state (Literal["redacted", "omitted"]): Whether the reasoning content
 * was redacted by the provider or simply omitted by the API hidden_reasoning
 * (Optional[str]): The internal reasoning of the agent
 */
export interface HiddenReasoningMessage {
  id: string;

  date: string;

  state: 'redacted' | 'omitted';

  hidden_reasoning?: string | null;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'hidden_reasoning_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

export interface ImageContent {
  /**
   * The source of the image.
   */
  source: ImageContent.URLImage | ImageContent.Base64Image | ImageContent.LettaImage;

  /**
   * The type of the message.
   */
  type?: 'image';
}

export namespace ImageContent {
  export interface URLImage {
    /**
     * The URL of the image.
     */
    url: string;

    /**
     * The source type for the image.
     */
    type?: 'url';
  }

  export interface Base64Image {
    /**
     * The base64 encoded image data.
     */
    data: string;

    /**
     * The media type for the image.
     */
    media_type: string;

    /**
     * What level of detail to use when processing and understanding the image (low,
     * high, or auto to let the model decide)
     */
    detail?: string | null;

    /**
     * The source type for the image.
     */
    type?: 'base64';
  }

  export interface LettaImage {
    /**
     * The unique identifier of the image file persisted in storage.
     */
    file_id: string;

    /**
     * The base64 encoded image data.
     */
    data?: string | null;

    /**
     * What level of detail to use when processing and understanding the image (low,
     * high, or auto to let the model decide)
     */
    detail?: string | null;

    /**
     * The media type for the image.
     */
    media_type?: string | null;

    /**
     * The source type for the image.
     */
    type?: 'letta';
  }
}

/**
 * Status of the job.
 */
export type JobStatus = 'created' | 'running' | 'completed' | 'failed' | 'pending' | 'cancelled' | 'expired';

export type JobType = 'job' | 'run' | 'batch';

export interface LettaAssistantMessageContentUnion {
  /**
   * The text content of the message.
   */
  text: string;

  /**
   * The type of the message.
   */
  type?: 'text';
}

/**
 * A message generated by the system. Never streamed back on a response, only used
 * for cursor pagination.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message content (str): The message content sent by the system
 */
export type LettaMessageUnion =
  | SystemMessage
  | UserMessage
  | ReasoningMessage
  | HiddenReasoningMessage
  | ToolCallMessage
  | ToolsAPI.ToolReturnMessage
  | AssistantMessage
  | ApprovalRequestMessage
  | ApprovalResponseMessage;

export interface LettaRequest {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;

  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;

  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;

  /**
   * Only return specified message types in the response. If `None` (default) returns
   * all messages.
   */
  include_return_message_types?: Array<MessageType> | null;

  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;

  /**
   * Whether the server should parse specific tool call arguments (default
   * `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
}

/**
 * Response object from an agent interaction, consisting of the new messages
 * generated by the agent and usage statistics. The type of the returned messages
 * can be either `Message` or `LettaMessage`, depending on what was specified in
 * the request.
 *
 * Attributes: messages (List[Union[Message, LettaMessage]]): The messages returned
 * by the agent. usage (LettaUsageStatistics): The usage statistics
 */
export interface LettaResponse {
  /**
   * The messages returned by the agent.
   */
  messages: Array<LettaMessageUnion>;

  /**
   * The stop reason from Letta indicating why agent loop stopped execution.
   */
  stop_reason: LettaResponse.StopReason;

  /**
   * The usage statistics of the agent.
   */
  usage: LettaResponse.Usage;
}

export namespace LettaResponse {
  /**
   * The stop reason from Letta indicating why agent loop stopped execution.
   */
  export interface StopReason {
    /**
     * The reason why execution stopped.
     */
    stop_reason: RunsAPI.StopReasonType;

    /**
     * The type of the message.
     */
    message_type?: 'stop_reason';
  }

  /**
   * The usage statistics of the agent.
   */
  export interface Usage {
    /**
     * The number of tokens generated by the agent.
     */
    completion_tokens?: number;

    message_type?: 'usage_statistics';

    /**
     * The number of tokens in the prompt.
     */
    prompt_tokens?: number;

    /**
     * The background task run IDs associated with the agent interaction
     */
    run_ids?: Array<string> | null;

    /**
     * The number of steps taken by the agent.
     */
    step_count?: number;

    /**
     * The messages generated per step
     */
    steps_messages?: Array<Array<MessagesAPI.Message>> | null;

    /**
     * The total number of tokens processed by the agent.
     */
    total_tokens?: number;
  }
}

export interface LettaStreamingRequest {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;

  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;

  /**
   * Whether to process the request in the background.
   */
  background?: boolean;

  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;

  /**
   * Whether to include periodic keepalive ping messages in the stream to prevent
   * connection timeouts.
   */
  include_pings?: boolean;

  /**
   * Only return specified message types in the response. If `None` (default) returns
   * all messages.
   */
  include_return_message_types?: Array<MessageType> | null;

  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;

  /**
   * Flag to determine if individual tokens should be streamed, rather than streaming
   * per step.
   */
  stream_tokens?: boolean;

  /**
   * Whether the server should parse specific tool call arguments (default
   * `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
}

export type LettaUserMessageContentUnion = TextContent | ImageContent;

/**
 * Letta's internal representation of a message. Includes methods to convert to/from LLM provider formats.
 *
 *     Attributes:
 *         id (str): The unique identifier of the message.
 *         role (MessageRole): The role of the participant.
 *         text (str): The text of the message.
 *         user_id (str): The unique identifier of the user.
 *         agent_id (str): The unique identifier of the agent.
 *         model (str): The model used to make the function call.
 *         name (str): The name of the participant.
 *         created_at (datetime): The time the message was created.
 *         tool_calls (List[OpenAIToolCall,]): The list of tool calls requested.
 *         tool_call_id (str): The id of the tool call.
 *         step_id (str): The id of the step that this message was created in.
 *         otid (str): The offline threading id associated with this message.
 *         tool_returns (List[ToolReturn]): The list of tool returns requested.
 *         group_id (str): The multi-agent group that the message was sent in.
 *         sender_id (str): The id of the sender of the message, can be an identity id or agent id.
 *
 * t
 */
export interface Message {
  /**
   * The role of the participant.
   */
  role: MessageRole;

  /**
   * The human-friendly ID of the Message
   */
  id?: string;

  /**
   * The unique identifier of the agent.
   */
  agent_id?: string | null;

  /**
   * The id of the approval request if this message is associated with a tool call
   * request.
   */
  approval_request_id?: string | null;

  /**
   * Whether tool call is approved.
   */
  approve?: boolean | null;

  /**
   * The id of the LLMBatchItem that this message is associated with
   */
  batch_item_id?: string | null;

  /**
   * The content of the message.
   */
  content?: Array<
    | TextContent
    | ImageContent
    | ToolCallContent
    | ToolReturnContent
    | ReasoningContent
    | RedactedReasoningContent
    | OmittedReasoningContent
  > | null;

  /**
   * The timestamp when the object was created.
   */
  created_at?: string;

  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;

  /**
   * The reason the tool call request was denied.
   */
  denial_reason?: string | null;

  /**
   * The multi-agent group that the message was sent in
   */
  group_id?: string | null;

  /**
   * Whether this message is part of an error step. Used only for debugging purposes.
   */
  is_err?: boolean | null;

  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;

  /**
   * The model used to make the function call.
   */
  model?: string | null;

  /**
   * For role user/assistant: the (optional) name of the participant. For role
   * tool/function: the name of the function called.
   */
  name?: string | null;

  /**
   * The offline threading id associated with this message
   */
  otid?: string | null;

  /**
   * The id of the sender of the message, can be an identity id or agent id
   */
  sender_id?: string | null;

  /**
   * The id of the step that this message was created in.
   */
  step_id?: string | null;

  /**
   * The ID of the tool call. Only applicable for role tool.
   */
  tool_call_id?: string | null;

  /**
   * The list of tool calls requested. Only applicable for role assistant.
   */
  tool_calls?: Array<Message.ToolCall> | null;

  /**
   * Tool execution return information for prior tool calls
   */
  tool_returns?: Array<ToolReturn> | null;

  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
}

export namespace Message {
  export interface ToolCall {
    id: string;

    function: ToolCall.Function;

    type: 'function';

    [k: string]: unknown;
  }

  export namespace ToolCall {
    export interface Function {
      arguments: string;

      name: string;

      [k: string]: unknown;
    }
  }
}

export type MessageRole = 'assistant' | 'user' | 'tool' | 'function' | 'system' | 'approval';

export type MessageType =
  | 'system_message'
  | 'user_message'
  | 'assistant_message'
  | 'reasoning_message'
  | 'hidden_reasoning_message'
  | 'tool_call_message'
  | 'tool_return_message'
  | 'approval_request_message'
  | 'approval_response_message';

export interface OmittedReasoningContent {
  /**
   * Indicates this is an omitted reasoning step.
   */
  type?: 'omitted_reasoning';
}

export interface ReasoningContent {
  /**
   * Whether the reasoning content was generated by a reasoner model that processed
   * this step.
   */
  is_native: boolean;

  /**
   * The intermediate reasoning or thought process content.
   */
  reasoning: string;

  /**
   * A unique identifier for this reasoning step.
   */
  signature?: string | null;

  /**
   * Indicates this is a reasoning/intermediate step.
   */
  type?: 'reasoning';
}

/**
 * Representation of an agent's internal reasoning.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message source (Literal["reasoner_model", "non_reasoner_model"]): Whether the
 * reasoning content was generated natively by a reasoner model or derived via
 * prompting reasoning (str): The internal reasoning of the agent signature
 * (Optional[str]): The model-generated signature of the reasoning step
 */
export interface ReasoningMessage {
  id: string;

  date: string;

  reasoning: string;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'reasoning_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  signature?: string | null;

  source?: 'reasoner_model' | 'non_reasoner_model';

  step_id?: string | null;
}

export interface RedactedReasoningContent {
  /**
   * The redacted or filtered intermediate reasoning content.
   */
  data: string;

  /**
   * Indicates this is a redacted thinking step.
   */
  type?: 'redacted_reasoning';
}

/**
 * Representation of a run, which is a job with a 'run' prefix in its ID. Inherits
 * all fields and behavior from Job except for the ID prefix.
 *
 * Parameters: id (str): The unique identifier of the run (prefixed with 'run-').
 * status (JobStatus): The status of the run. created_at (datetime): The unix
 * timestamp of when the run was created. completed_at (datetime): The unix
 * timestamp of when the run was completed. user_id (str): The unique identifier of
 * the user associated with the run.
 */
export interface Run {
  /**
   * The human-friendly ID of the Run
   */
  id?: string;

  /**
   * Optional error message from attempting to POST the callback endpoint.
   */
  callback_error?: string | null;

  /**
   * Timestamp when the callback was last attempted.
   */
  callback_sent_at?: string | null;

  /**
   * HTTP status code returned by the callback endpoint.
   */
  callback_status_code?: number | null;

  /**
   * If set, POST to this URL when the job completes.
   */
  callback_url?: string | null;

  /**
   * The unix timestamp of when the job was completed.
   */
  completed_at?: string | null;

  /**
   * The unix timestamp of when the job was created.
   */
  created_at?: string;

  /**
   * The id of the user that made this object.
   */
  created_by_id?: string | null;

  job_type?: JobType;

  /**
   * The id of the user that made this object.
   */
  last_updated_by_id?: string | null;

  /**
   * The metadata of the job.
   */
  metadata?: { [key: string]: unknown } | null;

  /**
   * The request configuration for the run.
   */
  request_config?: Run.RequestConfig | null;

  /**
   * The status of the job.
   */
  status?: JobStatus;

  /**
   * The reason why the run was stopped.
   */
  stop_reason?: RunsAPI.StopReasonType | null;

  /**
   * Total run duration in nanoseconds
   */
  total_duration_ns?: number | null;

  /**
   * Time to first token for a run in nanoseconds
   */
  ttft_ns?: number | null;

  /**
   * The timestamp when the object was last updated.
   */
  updated_at?: string | null;
}

export namespace Run {
  /**
   * The request configuration for the run.
   */
  export interface RequestConfig {
    /**
     * The name of the message argument in the designated message tool.
     */
    assistant_message_tool_kwarg?: string;

    /**
     * The name of the designated message tool.
     */
    assistant_message_tool_name?: string;

    /**
     * Only return specified message types in the response. If `None` (default) returns
     * all messages.
     */
    include_return_message_types?: Array<MessagesAPI.MessageType> | null;

    /**
     * Whether the server should parse specific tool call arguments (default
     * `send_message`) as `AssistantMessage` objects.
     */
    use_assistant_message?: boolean;
  }
}

/**
 * A message generated by the system. Never streamed back on a response, only used
 * for cursor pagination.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message content (str): The message content sent by the system
 */
export interface SystemMessage {
  id: string;

  /**
   * The message content sent by the system
   */
  content: string;

  date: string;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'system_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

export interface TextContent {
  /**
   * The text content of the message.
   */
  text: string;

  /**
   * The type of the message.
   */
  type?: 'text';
}

export interface ToolCall {
  arguments: string;

  name: string;

  tool_call_id: string;
}

export interface ToolCallContent {
  /**
   * A unique identifier for this specific tool call instance.
   */
  id: string;

  /**
   * The parameters being passed to the tool, structured as a dictionary of parameter
   * names to values.
   */
  input: { [key: string]: unknown };

  /**
   * The name of the tool being called.
   */
  name: string;

  /**
   * Indicates this content represents a tool call event.
   */
  type?: 'tool_call';
}

export interface ToolCallDelta {
  arguments?: string | null;

  name?: string | null;

  tool_call_id?: string | null;
}

/**
 * A message representing a request to call a tool (generated by the LLM to trigger
 * tool execution).
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message tool_call (Union[ToolCall, ToolCallDelta]): The tool call
 */
export interface ToolCallMessage {
  id: string;

  date: string;

  tool_call: ToolCall | ToolCallDelta;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'tool_call_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

export interface ToolReturn {
  /**
   * The status of the tool call
   */
  status: 'success' | 'error';

  /**
   * Captured stderr from the tool invocation
   */
  stderr?: Array<string> | null;

  /**
   * Captured stdout (e.g. prints, logs) from the tool invocation
   */
  stdout?: Array<string> | null;
}

export interface ToolReturnContent {
  /**
   * The content returned by the tool execution.
   */
  content: string;

  /**
   * Indicates whether the tool execution resulted in an error.
   */
  is_error: boolean;

  /**
   * References the ID of the ToolCallContent that initiated this tool call.
   */
  tool_call_id: string;

  /**
   * Indicates this content represents a tool return event.
   */
  type?: 'tool_return';
}

export interface UpdateAssistantMessage {
  /**
   * The message content sent by the assistant (can be a string or an array of
   * content parts)
   */
  content: Array<LettaAssistantMessageContentUnion> | string;

  message_type?: 'assistant_message';
}

export interface UpdateReasoningMessage {
  reasoning: string;

  message_type?: 'reasoning_message';
}

export interface UpdateSystemMessage {
  /**
   * The message content sent by the system (can be a string or an array of
   * multi-modal content parts)
   */
  content: string;

  message_type?: 'system_message';
}

export interface UpdateUserMessage {
  /**
   * The message content sent by the user (can be a string or an array of multi-modal
   * content parts)
   */
  content: Array<LettaUserMessageContentUnion> | string;

  message_type?: 'user_message';
}

/**
 * A message sent by the user. Never streamed back on a response, only used for
 * cursor pagination.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message content (Union[str, List[LettaUserMessageContentUnion]]): The message
 * content sent by the user (can be a string or an array of multi-modal content
 * parts)
 */
export interface UserMessage {
  id: string;

  /**
   * The message content sent by the user (can be a string or an array of multi-modal
   * content parts)
   */
  content: Array<LettaUserMessageContentUnion> | string;

  date: string;

  is_err?: boolean | null;

  /**
   * The type of the message.
   */
  message_type?: 'user_message';

  name?: string | null;

  otid?: string | null;

  run_id?: string | null;

  sender_id?: string | null;

  seq_id?: number | null;

  step_id?: string | null;
}

/**
 * A message generated by the system. Never streamed back on a response, only used
 * for cursor pagination.
 *
 * Args: id (str): The ID of the message date (datetime): The date the message was
 * created in ISO format name (Optional[str]): The name of the sender of the
 * message content (str): The message content sent by the system
 */
export type MessageUpdateResponse =
  | SystemMessage
  | UserMessage
  | ReasoningMessage
  | HiddenReasoningMessage
  | ToolCallMessage
  | ToolsAPI.ToolReturnMessage
  | AssistantMessage
  | ApprovalRequestMessage
  | ApprovalResponseMessage;

export type MessageListResponse = Array<LettaMessageUnion>;

export type MessageCancelResponse = { [key: string]: unknown };

export type MessagePreviewRawPayloadResponse = { [key: string]: unknown };

export type MessageSearchResponse = Array<MessageSearchResponse.MessageSearchResponseItem>;

export namespace MessageSearchResponse {
  /**
   * Result from a message search operation with scoring details.
   */
  export interface MessageSearchResponseItem {
    /**
     * The embedded content (LLM-friendly)
     */
    embedded_text: string;

    /**
     * The raw message object
     */
    message: MessagesAPI.Message;

    /**
     * Reciprocal Rank Fusion combined score
     */
    rrf_score: number;

    /**
     * Full-text search rank position if FTS was used
     */
    fts_rank?: number | null;

    /**
     * Vector search rank position if vector search was used
     */
    vector_rank?: number | null;
  }
}

export type MessageSendStreamResponse = unknown;

export type MessageUpdateParams =
  | MessageUpdateParams.UpdateSystemMessage
  | MessageUpdateParams.UpdateUserMessage
  | MessageUpdateParams.UpdateReasoningMessage
  | MessageUpdateParams.UpdateAssistantMessage;

export declare namespace MessageUpdateParams {
  export interface UpdateSystemMessage {
    /**
     * Path param:
     */
    agent_id: string;

    /**
     * Body param: The message content sent by the system (can be a string or an array
     * of multi-modal content parts)
     */
    content: string;

    /**
     * Body param:
     */
    message_type?: 'system_message';
  }

  export interface UpdateUserMessage {
    /**
     * Path param:
     */
    agent_id: string;

    /**
     * Body param: The message content sent by the user (can be a string or an array of
     * multi-modal content parts)
     */
    content: Array<LettaUserMessageContentUnion> | string;

    /**
     * Body param:
     */
    message_type?: 'user_message';
  }

  export interface UpdateReasoningMessage {
    /**
     * Path param:
     */
    agent_id: string;

    /**
     * Body param:
     */
    reasoning: string;

    /**
     * Body param:
     */
    message_type?: 'reasoning_message';
  }

  export interface UpdateAssistantMessage {
    /**
     * Path param:
     */
    agent_id: string;

    /**
     * Body param: The message content sent by the assistant (can be a string or an
     * array of content parts)
     */
    content: Array<LettaAssistantMessageContentUnion> | string;

    /**
     * Body param:
     */
    message_type?: 'assistant_message';
  }
}

export interface MessageListParams {
  /**
   * Message after which to retrieve the returned messages.
   */
  after?: string | null;

  /**
   * The name of the message argument.
   */
  assistant_message_tool_kwarg?: string;

  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;

  /**
   * Message before which to retrieve the returned messages.
   */
  before?: string | null;

  /**
   * Group ID to filter messages by.
   */
  group_id?: string | null;

  /**
   * Whether to include error messages and error statuses. For debugging purposes
   * only.
   */
  include_err?: boolean | null;

  /**
   * Maximum number of messages to retrieve.
   */
  limit?: number;

  /**
   * Whether to use assistant messages
   */
  use_assistant_message?: boolean;
}

export interface MessageCancelParams {
  /**
   * Optional list of run IDs to cancel
   */
  run_ids?: Array<string> | null;
}

export type MessagePreviewRawPayloadParams =
  | MessagePreviewRawPayloadParams.LettaRequest
  | MessagePreviewRawPayloadParams.LettaStreamingRequest;

export declare namespace MessagePreviewRawPayloadParams {
  export interface LettaRequest {
    /**
     * The messages to be sent to the agent.
     */
    messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

    /**
     * The name of the message argument in the designated message tool.
     */
    assistant_message_tool_kwarg?: string;

    /**
     * The name of the designated message tool.
     */
    assistant_message_tool_name?: string;

    /**
     * If set to True, enables reasoning before responses or tool calls from the agent.
     */
    enable_thinking?: string;

    /**
     * Only return specified message types in the response. If `None` (default) returns
     * all messages.
     */
    include_return_message_types?: Array<MessageType> | null;

    /**
     * Maximum number of steps the agent should take to process the request.
     */
    max_steps?: number;

    /**
     * Whether the server should parse specific tool call arguments (default
     * `send_message`) as `AssistantMessage` objects.
     */
    use_assistant_message?: boolean;
  }

  export interface LettaStreamingRequest {
    /**
     * The messages to be sent to the agent.
     */
    messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

    /**
     * The name of the message argument in the designated message tool.
     */
    assistant_message_tool_kwarg?: string;

    /**
     * The name of the designated message tool.
     */
    assistant_message_tool_name?: string;

    /**
     * Whether to process the request in the background.
     */
    background?: boolean;

    /**
     * If set to True, enables reasoning before responses or tool calls from the agent.
     */
    enable_thinking?: string;

    /**
     * Whether to include periodic keepalive ping messages in the stream to prevent
     * connection timeouts.
     */
    include_pings?: boolean;

    /**
     * Only return specified message types in the response. If `None` (default) returns
     * all messages.
     */
    include_return_message_types?: Array<MessageType> | null;

    /**
     * Maximum number of steps the agent should take to process the request.
     */
    max_steps?: number;

    /**
     * Flag to determine if individual tokens should be streamed, rather than streaming
     * per step.
     */
    stream_tokens?: boolean;

    /**
     * Whether the server should parse specific tool call arguments (default
     * `send_message`) as `AssistantMessage` objects.
     */
    use_assistant_message?: boolean;
  }
}

export interface MessageSearchParams {
  /**
   * Filter messages created on or before this date
   */
  end_date?: string | null;

  /**
   * Maximum number of results to return
   */
  limit?: number;

  /**
   * Filter messages by project ID
   */
  project_id?: string | null;

  /**
   * Text query for full-text search
   */
  query?: string | null;

  /**
   * Filter messages by role
   */
  roles?: Array<MessageRole> | null;

  /**
   * Search mode to use
   */
  search_mode?: 'vector' | 'fts' | 'hybrid';

  /**
   * Filter messages created after this date
   */
  start_date?: string | null;

  /**
   * Filter messages by template ID
   */
  template_id?: string | null;
}

export interface MessageSendParams {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;

  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;

  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;

  /**
   * Only return specified message types in the response. If `None` (default) returns
   * all messages.
   */
  include_return_message_types?: Array<MessageType> | null;

  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;

  /**
   * Whether the server should parse specific tool call arguments (default
   * `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
}

export interface MessageSendAsyncParams {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;

  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;

  /**
   * Optional callback URL to POST to when the job completes
   */
  callback_url?: string | null;

  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;

  /**
   * Only return specified message types in the response. If `None` (default) returns
   * all messages.
   */
  include_return_message_types?: Array<MessageType> | null;

  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;

  /**
   * Whether the server should parse specific tool call arguments (default
   * `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
}

export interface MessageSendStreamParams {
  /**
   * The messages to be sent to the agent.
   */
  messages: Array<AgentsAPI.MessageCreate | ApprovalCreate>;

  /**
   * The name of the message argument in the designated message tool.
   */
  assistant_message_tool_kwarg?: string;

  /**
   * The name of the designated message tool.
   */
  assistant_message_tool_name?: string;

  /**
   * Whether to process the request in the background.
   */
  background?: boolean;

  /**
   * If set to True, enables reasoning before responses or tool calls from the agent.
   */
  enable_thinking?: string;

  /**
   * Whether to include periodic keepalive ping messages in the stream to prevent
   * connection timeouts.
   */
  include_pings?: boolean;

  /**
   * Only return specified message types in the response. If `None` (default) returns
   * all messages.
   */
  include_return_message_types?: Array<MessageType> | null;

  /**
   * Maximum number of steps the agent should take to process the request.
   */
  max_steps?: number;

  /**
   * Flag to determine if individual tokens should be streamed, rather than streaming
   * per step.
   */
  stream_tokens?: boolean;

  /**
   * Whether the server should parse specific tool call arguments (default
   * `send_message`) as `AssistantMessage` objects.
   */
  use_assistant_message?: boolean;
}

export declare namespace Messages {
  export {
    type ApprovalCreate as ApprovalCreate,
    type ApprovalRequestMessage as ApprovalRequestMessage,
    type ApprovalResponseMessage as ApprovalResponseMessage,
    type AssistantMessage as AssistantMessage,
    type HiddenReasoningMessage as HiddenReasoningMessage,
    type ImageContent as ImageContent,
    type JobStatus as JobStatus,
    type JobType as JobType,
    type LettaAssistantMessageContentUnion as LettaAssistantMessageContentUnion,
    type LettaMessageUnion as LettaMessageUnion,
    type LettaRequest as LettaRequest,
    type LettaResponse as LettaResponse,
    type LettaStreamingRequest as LettaStreamingRequest,
    type LettaUserMessageContentUnion as LettaUserMessageContentUnion,
    type Message as Message,
    type MessageRole as MessageRole,
    type MessageType as MessageType,
    type OmittedReasoningContent as OmittedReasoningContent,
    type ReasoningContent as ReasoningContent,
    type ReasoningMessage as ReasoningMessage,
    type RedactedReasoningContent as RedactedReasoningContent,
    type Run as Run,
    type SystemMessage as SystemMessage,
    type TextContent as TextContent,
    type ToolCall as ToolCall,
    type ToolCallContent as ToolCallContent,
    type ToolCallDelta as ToolCallDelta,
    type ToolCallMessage as ToolCallMessage,
    type ToolReturn as ToolReturn,
    type ToolReturnContent as ToolReturnContent,
    type UpdateAssistantMessage as UpdateAssistantMessage,
    type UpdateReasoningMessage as UpdateReasoningMessage,
    type UpdateSystemMessage as UpdateSystemMessage,
    type UpdateUserMessage as UpdateUserMessage,
    type UserMessage as UserMessage,
    type MessageUpdateResponse as MessageUpdateResponse,
    type MessageListResponse as MessageListResponse,
    type MessageCancelResponse as MessageCancelResponse,
    type MessagePreviewRawPayloadResponse as MessagePreviewRawPayloadResponse,
    type MessageSearchResponse as MessageSearchResponse,
    type MessageSendStreamResponse as MessageSendStreamResponse,
    type MessageUpdateParams as MessageUpdateParams,
    type MessageListParams as MessageListParams,
    type MessageCancelParams as MessageCancelParams,
    type MessagePreviewRawPayloadParams as MessagePreviewRawPayloadParams,
    type MessageSearchParams as MessageSearchParams,
    type MessageSendParams as MessageSendParams,
    type MessageSendAsyncParams as MessageSendAsyncParams,
    type MessageSendStreamParams as MessageSendStreamParams,
  };
}
